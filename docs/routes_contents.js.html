<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: routes/contents.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: routes/contents.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module routes/contents
 */
import multipart from '@fastify/multipart';
import fs from 'fs';
import path from 'path';
import { Queue } from 'bullmq';
/**
 * @function contentsProxy
 * @memberof module:routes/contents
 * @summary It proxies the requests that come from the client to the contents microservice
 * @param fastify The fastify instance
 * @param opts The options for the fastify plugin
 */
export default async function contentsProxy(fastify, opts) {
    const contentsServiceUrl = process.env.CONTENTS_SERVICE_URL || 'http://localhost:8000/api';
    const queue = new Queue('video-queue', {
        connection: {
            host: process.env.REDIS_HOST || 'localhost',
            port: parseInt(String(process.env.REDIS_PORT)) || 6379,
        },
    });
    fastify.register(multipart, {
        limits: {
            fileSize: 1000 * 1024 * 1024
        }
    });
    registerActors(fastify, contentsServiceUrl);
    registerDirectors(fastify, contentsServiceUrl);
    registerGenres(fastify, contentsServiceUrl);
    registerMovies(fastify, contentsServiceUrl, queue);
    registerShows(fastify, contentsServiceUrl);
    registerEpisodes(fastify, contentsServiceUrl, queue);
}
/**
 * It register the specific routes for actors
 * @param fastify The fastify instance
 * @param contentsServiceUrl The URL for the contents microservice
 */
function registerActors(fastify, contentsServiceUrl) {
    /**
     * @name GET /actors
     * @function
     * @memberof module:routes/contents
     * @summary It retrieves from the microservice every existing actor
     */
    fastify.get('/actors', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const res = await fetch(`${contentsServiceUrl}/actors`, {
            method: 'GET',
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name GET /actors/:iud
     * @function
     * @memberof module:routes/contents
     * @summary It retrieves from the micorservvice a specfic actor
     */
    fastify.get('/actors/:id', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const id = request.params.id;
        const res = await fetch(`${contentsServiceUrl}/actors/${id}`, {
            method: 'GET',
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name POST /actors
     * @function
     * @memberof module:routes/contents
     * @summary It calls the microservice to create a new actor
     */
    fastify.post('/actors', { preHandler: [fastify.authenticate, fastify.requireAdmin] }, async (request, reply) => {
        const res = await fetch(`${contentsServiceUrl}/actors`, {
            method: 'POST',
            headers: {
                "Content-Type": 'application/json',
            },
            body: JSON.stringify(request.body),
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name GET /movies/:id/actors
     * @function
     * @memberof module:routes/contents
     * @summary It retrieves from the microservice every actor in a movie
     */
    fastify.get('/movies/:id/actors', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const id = request.params.id;
        const res = await fetch(`${contentsServiceUrl}/movies/${id}/actors`, {
            method: 'GET',
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name GET /shows/:id/actors
     * @function
     * @memberof module:routes/contents
     * @summary It retrieves from the microservice every actor in a show
     */
    fastify.get('/shows/:id/actors', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const id = request.params.id;
        const res = await fetch(`${contentsServiceUrl}/shows/${id}/actors`, {
            method: 'GET',
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name PATCH /actors/:ud
     * @function
     * @memberof module:routes/contents
     * @summary It calls the microservice to update an existing actor
     */
    fastify.patch('/actors/:id', { preHandler: [fastify.authenticate, fastify.requireAdmin] }, async (request, reply) => {
        const id = request.params.id;
        const res = await fetch(`${contentsServiceUrl}/actors/${id}`, {
            method: 'PATCH',
            headers: {
                "Content-Type": 'application/json',
            },
            body: JSON.stringify(request.body),
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name DELETE /actors/:id
     * @function
     * @memberof module:routes/contents
     * @summary It calls the microservice to delete an existing microservice
     */
    fastify.delete('/actors/:id', { preHandler: [fastify.authenticate, fastify.requireAdmin] }, async (request, reply) => {
        const id = request.params.id;
        const res = await fetch(`${contentsServiceUrl}/actors/${id}`, {
            method: 'DELETE',
        });
        const data = await res.json();
        return reply.send(data);
    });
}
/**
 * It register the specific routes for directors
 * @param fastify The fastify instance
 * @param contentsServiceUrl The URL for the contents microservice
 */
function registerDirectors(fastify, contentsServiceUrl) {
    /**
     * @name GET /directors
     * @function
     * @memberof module:routes/contents
     * @summary It retrieves from the microservice every existing director
     */
    fastify.get('/directors', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const res = await fetch(`${contentsServiceUrl}/directors`, {
            method: 'GET',
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name GET /directors/:id
     * @function
     * @memberof module:routes/contents
     * @summary It retrieves from the microservice a specific director
     */
    fastify.get('/directors/:id', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const id = request.params.id;
        const res = await fetch(`${contentsServiceUrl}/directors/${id}`, {
            method: 'GET',
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name POST /directors
     * @function
     * @memberof module:routes/contents
     * @summary It calls the microservice to create a new director
     */
    fastify.post('/directors', { preHandler: [fastify.authenticate, fastify.requireAdmin] }, async (request, reply) => {
        const res = await fetch(`${contentsServiceUrl}/directors`, {
            method: 'POST',
            headers: {
                "Content-Type": 'application/json',
            },
            body: JSON.stringify(request.body),
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name GET /movies/:id/directors
     * @function
     * @memberof module:routes/contents
     * @summary It retrieves from the microservice every director in a movie
     */
    fastify.get('/movies/:id/directors', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const id = request.params.id;
        const res = await fetch(`${contentsServiceUrl}/movies/${id}/directors`, {
            method: 'GET',
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name GET /shows/:id/directors
     * @function
     * @memberof module:routes/contents
     * @summary It retrieves from the microservice every director in a show
     */
    fastify.get('/shows/:id/directors', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const id = request.params.id;
        const res = await fetch(`${contentsServiceUrl}/shows/${id}/directors`, {
            method: 'GET',
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name PATCH /directors/:id
     * @function
     * @memberof module:routes/contents
     * @summary It calls the microservice to update an existing director
     */
    fastify.patch('/directors/:id', { preHandler: [fastify.authenticate, fastify.requireAdmin] }, async (request, reply) => {
        const id = request.params.id;
        const res = await fetch(`${contentsServiceUrl}/directors/${id}`, {
            method: 'PATCH',
            headers: {
                "Content-Type": 'application/json',
            },
            body: JSON.stringify(request.body),
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name DELETE /directors/:id
     * @function
     * @memberof module:routes/contents
     * @summary It calls the microservice to delete an existing director
     */
    fastify.delete('/directors/:id', { preHandler: [fastify.authenticate, fastify.requireAdmin] }, async (request, reply) => {
        const id = request.params.id;
        const res = await fetch(`${contentsServiceUrl}/directors/${id}`, {
            method: 'DELETE',
        });
        const data = await res.json();
        return reply.send(data);
    });
}
/**
 * It register the specific routes for genres
 * @param fastify The fastify instance
 * @param contentsServiceUrl The URL for the contents microservice
 */
function registerGenres(fastify, contentsServiceUrl) {
    /**
     * @name GET /genres
     * @function
     * @memberof module:routes/contents
     * @summary It retrieves from the microservice every existing genre
     */
    fastify.get('/genres', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const res = await fetch(`${contentsServiceUrl}/genres`, {
            method: 'GET',
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name GET /genres/:id
     * @function
     * @memberof module:routes/contents
     * @summary It retrieves from the microservice a specific genre
     */
    fastify.get('/genres/:id', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const id = request.params.id;
        const res = await fetch(`${contentsServiceUrl}/genres/${id}`, {
            method: 'GET',
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name POST /genres
     * @function
     * @memberof module:routes/contents
     * @summary It calls the microservice to create a new genre
     */
    fastify.post('/genres', { preHandler: [fastify.authenticate, fastify.requireAdmin] }, async (request, reply) => {
        const res = await fetch(`${contentsServiceUrl}/genres`, {
            method: 'POST',
            headers: {
                "Content-Type": 'application/json',
            },
            body: JSON.stringify(request.body),
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name PATCH /genres/:id
     * @function
     * @memberof module:routes/contents
     * @summary It calls the microservice to update an existing genre
     */
    fastify.patch('/genres/:id', { preHandler: [fastify.authenticate, fastify.requireAdmin] }, async (request, reply) => {
        const id = request.params.id;
        const res = await fetch(`${contentsServiceUrl}/genres/${id}`, {
            method: 'PATCH',
            headers: {
                "Content-Type": 'application/json',
            },
            body: JSON.stringify(request.body),
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name DELETE /genres/:id
     * @function
     * @memberof module:routes/contents
     * @summary It calls the microservice to delete an existing genre
     */
    fastify.delete('/genres/:id', { preHandler: [fastify.authenticate, fastify.requireAdmin] }, async (request, reply) => {
        const id = request.params.id;
        const res = await fetch(`${contentsServiceUrl}/genres/${id}`, {
            method: 'DELETE',
        });
        const data = await res.json();
        return reply.send(data);
    });
}
/**
 * It register the specific routes for movies
 * @param fastify The fastify instance
 * @param contentsServiceUrl The URL for the contents microservice
 */
function registerMovies(fastify, contentsServiceUrl, queue) {
    /**
     * @name POST /movies
     * @function
     * @memberof module:routes/contents
     * @summary It calls the microservice to create a new movie after saving the file and creating a work in a Redis queue so another program transcodes it.
     */
    fastify.post('/movies', { preHandler: [fastify.authenticate, fastify.requireAdmin] }, async (request, reply) => {
        const parts = request.parts();
        const metadata = {};
        let videoFileBuffer = null;
        let videoFileName = null;
        for await (const part of parts) {
            if (part.type === 'file') {
                videoFileName = part.filename;
                videoFileBuffer = await part.toBuffer();
            }
            else if (part.type === 'field' &amp;&amp; part.fieldname !== 'url') {
                const name = part.fieldname;
                if (name.endsWith("[]")) {
                    const key = name.replace("[]", "");
                    if (!metadata[key]) {
                        metadata[key] = [];
                    }
                    metadata[key].push(part.value);
                }
                else {
                    metadata[name] = part.value;
                }
            }
        }
        if (!videoFileBuffer || !videoFileName) {
            return reply.code(400).send({ error: 'Missing file' });
        }
        const fileKey = `${Date.now()}_${videoFileName}`;
        const dirPath = path.join('/uploads/raw/movies');
        const filePath = path.join(dirPath, fileKey);
        await fs.promises.mkdir(dirPath, { recursive: true });
        await fs.promises.writeFile(filePath, videoFileBuffer);
        try {
            await queue.add('ffmpeg-conversion', {
                'inputPath': filePath,
                'outputFolder': `/uploads/vod/movies/${fileKey}`,
                'resolutions': [1080, 720, 480],
                'fileKey': fileKey
            }, {
                removeOnComplete: true,
                removeOnFail: false,
            });
        }
        catch (error) {
            fastify.log.error('Failed to enqueue job', error);
            return reply.code(500).send({ error: 'Failed to enqueue video conversion job.' });
        }
        const movieData = {
            ...metadata,
            genre_id: metadata.genre_id ? parseInt(metadata.genre_id, 10) : null,
            directors_ids: [].concat(metadata.directors_ids).map(id => parseInt(id, 10)).filter(n => !isNaN(n)),
            actors_ids: [].concat(metadata.actors_ids).map(id => parseInt(id, 10)).filter(n => !isNaN(n)),
            rating: metadata.rating ? parseFloat(metadata.rating) : null,
            release_date: metadata.release_date ? metadata.release_date : null,
            file_key: fileKey,
        };
        const res = await fetch(`${contentsServiceUrl}/movies`, {
            method: 'POST',
            headers: {
                "Content-Type": 'application/json',
            },
            body: JSON.stringify(movieData),
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name GET /movies
     * @function
     * @memberof module:routes/contents
     * @summary It retrieves from the microservice every existing movie
     */
    fastify.get('/movies', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const res = await fetch(`${contentsServiceUrl}/movies`, {
            method: 'GET',
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name GET /movies/:id
     * @function
     * @memberof module:routes/contents
     * @summary It retrieves from the microservice a specific movie
     */
    fastify.get('/movies/:id', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const id = request.params.id;
        const res = await fetch(`${contentsServiceUrl}/movies/${id}`, {
            method: 'GET',
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name GET /movies/:id/extended
     * @function
     * @memberof module:routes/contents
     * @summary It retrieves from the microservice a specific movie with extra data.
     */
    fastify.get('/movies/:id/extended', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const id = request.params.id;
        const res = await fetch(`${contentsServiceUrl}/movies/${id}/extended`, {
            method: 'GET',
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name GET /genres/:id/movies
     * @function
     * @memberof module:routes/contents
     * @summary It retrieves from the microservice every movie in a genre
     */
    fastify.get('/genres/:id/movies', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const id = request.params.id;
        const res = await fetch(`${contentsServiceUrl}/genres/${id}/movies`, {
            method: 'GET',
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name GET /actors/:id/movies
     * @function
     * @memberof module:routes/contents
     * @summary It retrieves from the microservice every movie with an actor
     */
    fastify.get('/actors/:id/movies', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const id = request.params.id;
        const res = await fetch(`${contentsServiceUrl}/actors/${id}/movies`, {
            method: 'GET',
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name /directors/:id/movies
     * @function
     * @memberof module:routes/contents
     * @summary It retrieves from the microservice every movie with a director
     */
    fastify.get('/directors/:id/movies', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const id = request.params.id;
        const res = await fetch(`${contentsServiceUrl}/directors/${id}/movies`, {
            method: 'GET',
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name PATCH /movies/:id
     * @function
     * @memberof module:routes/contents
     * @summary It calls the microservice to update a specific movie. It also saves the file and creates a work in a Redis queue so another program transcodes it if the file happened to exist.
     */
    fastify.patch('/movies/:id', { preHandler: [fastify.authenticate, fastify.requireAdmin] }, async (request, reply) => {
        const id = request.params.id;
        const parts = request.parts();
        const metadata = {};
        let videoFileBuffer = null;
        let videoFileName = null;
        for await (const part of parts) {
            if (part.type === 'file') {
                videoFileName = part.filename;
                videoFileBuffer = await part.toBuffer();
            }
            else if (part.type === 'field' &amp;&amp; part.fieldname !== 'url') {
                const name = part.fieldname;
                if (name.endsWith("[]")) {
                    const key = name.replace("[]", "");
                    if (!metadata[key]) {
                        metadata[key] = [];
                    }
                    metadata[key].push(part.value);
                }
                else {
                    metadata[name] = part.value;
                }
            }
        }
        let fileKey = null;
        if (videoFileBuffer &amp;&amp; videoFileName) {
            fileKey = `${Date.now()}_${videoFileName}`;
            const dirPath = path.join('/uploads/raw/movies');
            const filePath = path.join(dirPath, fileKey);
            await fs.promises.mkdir(dirPath, { recursive: true });
            await fs.promises.writeFile(filePath, videoFileBuffer);
            await queue.add('ffmpeg-conversion', {
                'input_path': filePath,
                'output_folder': `/uploads/vod/movies/${fileKey}`,
                'resolutions': [1080, 720, 480],
                'file_key': fileKey
            }, {
                removeOnComplete: true,
                removeOnFail: false,
            });
        }
        const movieData = {
            ...metadata,
            genre_id: metadata.genre_id ? parseInt(metadata.genre_id, 10) : null,
            directors_ids: [].concat(metadata.directors_ids).map(id => parseInt(id, 10)).filter(n => !isNaN(n)),
            actors_ids: [].concat(metadata.actors_ids).map(id => parseInt(id, 10)).filter(n => !isNaN(n)),
            rating: metadata.rating ? parseFloat(metadata.rating) : null,
            release_date: metadata.release_date ? metadata.release_date : null,
            file_key: fileKey ?? null,
        };
        const res = await fetch(`${contentsServiceUrl}/movies/${id}`, {
            method: 'PATCH',
            headers: {
                "Content-Type": 'application/json',
            },
            body: JSON.stringify(movieData),
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name DELETE /movies/:id
     * @function
     * @memberof module:routes/contents
     * @summary It calls the microservice to delete a specific movie
     */
    fastify.delete('/movies/:id', { preHandler: [fastify.authenticate, fastify.requireAdmin] }, async (request, reply) => {
        const id = request.params.id;
        const res = await fetch(`${contentsServiceUrl}/movies/${id}`, {
            method: 'DELETE',
        });
        const data = await res.json();
        return reply.send(data);
    });
}
/**
 * It register the specific routes for shows
 * @param fastify The fastify instance
 * @param contentsServiceUrl The URL for the contents microservice
 */
function registerShows(fastify, contentsServiceUrl) {
    /**
     * @name POST /shows
     * @function
     * @memberof module:routes/contents
     * @summary It calls the microservice to create a new show
     */
    fastify.post('/shows', { preHandler: [fastify.authenticate, fastify.requireAdmin] }, async (request, reply) => {
        const parts = request.parts();
        const metadata = {};
        for await (const part of parts) {
            if (part.type === 'field' &amp;&amp; part.fieldname !== 'url') {
                if (part.fieldname.endsWith("[]")) {
                    const key = part.fieldname.replace("[]", "");
                    if (!metadata[key]) {
                        metadata[key] = [];
                    }
                    metadata[key].push(part.value);
                }
                else {
                    metadata[part.fieldname] = part.value;
                }
            }
        }
        const showData = {
            ...metadata,
            seasons_num: metadata.seasons_num ? parseInt(metadata.seasons_num, 10) : null,
            genre_id: metadata.genre_id ? parseInt(metadata.genre_id, 10) : null,
            directors_ids: [].concat(metadata.directors_ids).map(id => parseInt(id, 10)).filter(n => !isNaN(n)),
            actors_ids: [].concat(metadata.actors_ids).map(id => parseInt(id, 10)).filter(n => !isNaN(n)),
            rating: metadata.rating ? parseFloat(metadata.rating) : null,
            release_date: metadata.release_date ? metadata.release_date : null
        };
        const res = await fetch(`${contentsServiceUrl}/shows`, {
            method: 'POST',
            headers: {
                "Content-Type": 'application/json',
            },
            body: JSON.stringify(showData),
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name GET /shows
     * @function
     * @memberof module:routes/contents
     * @summary It retrieves from the microservice every existing show
     */
    fastify.get('/shows', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const res = await fetch(`${contentsServiceUrl}/shows`, {
            method: 'GET',
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name GET /shows/:id
     * @function
     * @memberof module:routes/contents
     * @summary It retrieves from the microservice a specific show
     */
    fastify.get('/shows/:id', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const id = request.params.id;
        const res = await fetch(`${contentsServiceUrl}/shows/${id}`, {
            method: 'GET',
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name GET /shows/:id/extended
     * @function
     * @memberof module:routes/contents
     * @summary It retrieves from the microservice a specific show with extra data
     */
    fastify.get('/shows/:id/extended', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const id = request.params.id;
        const res = await fetch(`${contentsServiceUrl}/shows/${id}/extended`, {
            method: 'GET',
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name GET /genres/:id/shows
     * @function
     * @memberof module:routes/contents
     * @summary It returns every show in a genre
     */
    fastify.get('/genres/:id/shows', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const id = request.params.id;
        const res = await fetch(`${contentsServiceUrl}/genres/${id}/shows`, {
            method: 'GET',
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name GET /actors/:id/shows
     * @function
     * @memberof module:routes/contents
     * @summary It returns every show with an actor
     */
    fastify.get('/actors/:id/shows', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const id = request.params.id;
        const res = await fetch(`${contentsServiceUrl}/actors/${id}/shows`, {
            method: 'GET',
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name GET /directors/:id/shows
     * @function
     * @memberof module:routes/contents
     * @summary It returns every show with a director
     */
    fastify.get('/directors/:id/shows', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const id = request.params.id;
        const res = await fetch(`${contentsServiceUrl}/directors/${id}/shows`, {
            method: 'GET',
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name PATCH /shows/:id
     * @function
     * @memberof module:routes/contents
     * @summary It calls the microservice to update an existing show
     */
    fastify.patch('/shows/:id', { preHandler: [fastify.authenticate, fastify.requireAdmin] }, async (request, reply) => {
        const id = request.params.id;
        const parts = request.parts();
        const metadata = {};
        for await (const part of parts) {
            if (part.type === 'field' &amp;&amp; part.fieldname !== 'url') {
                if (part.fieldname.endsWith("[]")) {
                    const key = part.fieldname.replace("[]", "");
                    if (!metadata[key]) {
                        metadata[key] = [];
                    }
                    metadata[key].push(part.value);
                }
                else {
                    metadata[part.fieldname] = part.value;
                }
            }
        }
        const showData = {
            ...metadata,
            seasons_num: metadata.seasons_num ? parseInt(metadata.seasons_num, 10) : null,
            genre_id: metadata.genre_id ? parseInt(metadata.genre_id, 10) : null,
            directors_ids: [].concat(metadata.directors_ids).map(id => parseInt(id, 10)).filter(n => !isNaN(n)),
            actors_ids: [].concat(metadata.actors_ids).map(id => parseInt(id, 10)).filter(n => !isNaN(n)),
            rating: metadata.rating ? parseFloat(metadata.rating) : null,
            release_date: metadata.release_date ? metadata.release_date : null
        };
        console.log(showData);
        const res = await fetch(`${contentsServiceUrl}/shows/${id}`, {
            method: 'PATCH',
            headers: {
                "Content-Type": 'application/json',
            },
            body: JSON.stringify(showData),
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name DELETE /shows/:id
     * @function
     * @memberof module:routes/contents
     * @summary It calls the microservice to delete an existing show
     */
    fastify.delete('/shows/:id', { preHandler: [fastify.authenticate, fastify.requireAdmin] }, async (request, reply) => {
        const id = request.params.id;
        const res = await fetch(`${contentsServiceUrl}/shows/${id}`, {
            method: 'DELETE',
        });
        const data = await res.json();
        return reply.send(data);
    });
}
/**
 * It register the specific routes for episodes
 * @param fastify The fastify instance
 * @param contentsServiceUrl The URL for the contents microservice
 */
function registerEpisodes(fastify, contentsServiceUrl, queue) {
    /**
     * @name POST /episodes
     * @function
     * @memberof module:routes/contents
     * @summary It calls the microservice to create a new episode after saving the file and creating a job in a Redis queue so a different program transcodes it
     */
    fastify.post('/episodes', { preHandler: [fastify.authenticate, fastify.requireAdmin] }, async (request, reply) => {
        const parts = request.parts();
        const metadata = {};
        let videoFileBuffer = null;
        let videoFileName = null;
        for await (const part of parts) {
            if (part.type === 'file') {
                videoFileName = part.filename;
                videoFileBuffer = await part.toBuffer();
            }
            else if (part.fieldname != 'url') {
                metadata[part.fieldname] = part.value;
            }
        }
        if (!videoFileBuffer || !videoFileName) {
            return reply.code(400).send({ error: 'Missing file' });
        }
        const fileKey = `${Date.now()}_${videoFileName}`;
        const dirPath = path.join(`/uploads/raw/shows/${metadata['show_id']}/${metadata['season_num']}`);
        const filePath = path.join(dirPath, fileKey);
        await fs.promises.mkdir(dirPath, { recursive: true });
        await fs.promises.writeFile(filePath, videoFileBuffer);
        await queue.add('ffmpeg-conversion', {
            'input_path': filePath,
            'output_folder': `/uploads/vod/shows/${metadata['show_id']}/${metadata['season_num']}/${fileKey}`,
            'resolutions': [1080, 720, 480],
            'file_key': fileKey
        }, {
            removeOnComplete: true,
            removeOnFail: false,
        });
        const episodeData = {
            ...metadata,
            season_num: metadata.season_num ? parseInt(metadata.season_num, 10) : null,
            episode_num: metadata.episode_num ? parseInt(metadata.episode_num, 10) : null,
            release_date: metadata.release_date ? metadata.release_date : null,
            file_key: fileKey,
        };
        const res = await fetch(`${contentsServiceUrl}/episodes`, {
            method: 'POST',
            headers: {
                "Content-Type": 'application/json',
            },
            body: JSON.stringify(episodeData),
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name GET /shows/:id/episodes
     * @function
     * @memberof module:routes/contents
     * @summary It retrieves from the microservice every episode in a show
     */
    fastify.get('/shows/:id/episodes', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const id = request.params.id;
        const res = await fetch(`${contentsServiceUrl}/shows/${id}/episodes`, {
            method: 'GET',
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name GET /shows/:id/:seasonNum/episodes
     * @function
     * @memberof module:routes/contents
     * @summary It retrieves from the microservice every episode in a show and season
     */
    fastify.get('/shows/:id/:seasonNum/episodes', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const id = request.params.id;
        const seasonNum = request.params.seasonNum;
        const res = await fetch(`${contentsServiceUrl}/shows/${id}/${seasonNum}/episodes`, {
            method: 'GET',
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name GET /episodes/:id
     * @function
     * @memberof module:routes/contents
     * @summary It retrieves from the microservice a specific episode
     */
    fastify.get('/episodes/:id', { preHandler: [fastify.authenticate] }, async (request, reply) => {
        const id = request.params.id;
        const res = await fetch(`${contentsServiceUrl}/episodes/${id}`, {
            method: 'GET',
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name PATCH /episodes/:id
     * @function
     * @memberof module:routes/contents
     * @summary It calls the microservice to update an existing episode. It also saves the file and creates a job in a Redis queue so a differente program transcodes it if the file happened to exist
     */
    fastify.patch('/episodes/:id', { preHandler: [fastify.authenticate, fastify.requireAdmin] }, async (request, reply) => {
        const id = request.params.id;
        const parts = request.parts();
        const metadata = {};
        let videoFileBuffer = null;
        let videoFileName = null;
        for await (const part of parts) {
            if (part.type === 'file') {
                videoFileName = part.filename;
                videoFileBuffer = await part.toBuffer();
            }
            else if (part.fieldname != 'url') {
                metadata[part.fieldname] = part.value;
            }
        }
        let fileKey = null;
        if (videoFileBuffer &amp;&amp; videoFileName) {
            fileKey = `${Date.now()}_${videoFileName}`;
            const dirPath = path.join(`/uploads/raw/shows/${metadata['show_id']}/${metadata['season_num']}`);
            const filePath = path.join(dirPath, fileKey);
            await fs.promises.mkdir(dirPath, { recursive: true });
            await fs.promises.writeFile(filePath, videoFileBuffer);
            await queue.add('ffmpeg-conversion', {
                'input_path': filePath,
                'output_folder': `/uploads/vod/shows/${metadata['show_id']}/${metadata['season_num']}/${fileKey}`,
                'resolutions': [1080, 720, 480],
                'file_key': fileKey
            }, {
                removeOnComplete: true,
                removeOnFail: false,
            });
        }
        const episodeData = {
            ...metadata,
            season_num: metadata.season_num ? parseInt(metadata.season_num, 10) : null,
            episode_num: metadata.episode_num ? parseInt(metadata.episode_num, 10) : null,
            release_date: metadata.release_date ? metadata.release_date : null,
            file_key: fileKey ?? null,
        };
        const res = await fetch(`${contentsServiceUrl}/episodes/${id}`, {
            method: 'PATCH',
            headers: {
                "Content-Type": 'application/json',
            },
            body: JSON.stringify(episodeData),
        });
        const data = await res.json();
        return reply.send(data);
    });
    /**
     * @name DELETE /episodes/:id
     * @function
     * @memberof module:routes/contents
     * @summary It calls the microservice to delete an existing episode
     */
    fastify.delete('/episodes/:id', { preHandler: [fastify.authenticate, fastify.requireAdmin] }, async (request, reply) => {
        const id = request.params.id;
        const res = await fetch(`${contentsServiceUrl}/episodes/${id}`, {
            method: 'DELETE',
        });
        const data = await res.json();
        return reply.send(data);
    });
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-plugins_adminAuthenticator.html">plugins/adminAuthenticator</a></li><li><a href="module-plugins_jwt.html">plugins/jwt</a></li><li><a href="module-routes_contents.html">routes/contents</a></li><li><a href="module-routes_favourites.html">routes/favourites</a></li><li><a href="module-routes_history.html">routes/history</a></li><li><a href="module-routes_users.html">routes/users</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Mon Nov 24 2025 19:49:37 GMT+0100 (Central European Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
